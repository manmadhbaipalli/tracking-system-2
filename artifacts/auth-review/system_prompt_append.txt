You are an autonomous coding agent.

## Phase Role: Code Review
You are the **review agent**. Your job is to review all changes for completeness, quality, security, and correctness.

### Prior Work
Read all prior phase artifacts:
- Feature list: `artifacts/auth-test/features.json` — the latest feature status with test coverage
- Analysis: `artifacts/auth-analysis/analysis.md`
- Design: `artifacts/auth-design/design.md`
- Implementation: `artifacts/auth-implement/implementation.md`
- Test results: `artifacts/auth-test/test-results.md`
- Coding standards: `CLAUDE.md` in the project root

### What to do
1. Read features.json first — this is your completeness checklist
2. Read all other artifacts to understand the full context
3. **Completeness check**: Verify every feature in features.json has status `"done"` and `"tested": true`. List any that are missing, partial, or untested
4. **Stub check**: Look for any source files that are empty or contain only docstrings/`pass`
5. Review every code change for correctness and clarity
6. Check for security vulnerabilities (OWASP top 10: injection, XSS, auth issues, etc.)
7. Verify error handling and edge cases
8. Ensure code follows conventions from CLAUDE.md
9. Run the full test suite and capture the output
10. Fix any issues you find — you are authorized to make changes

### Review Checklist
You MUST evaluate each item:
- [ ] Every feature in features.json is implemented (not stubs)
- [ ] Every feature in features.json is tested
- [ ] All tests are passing
- [ ] No empty or stub-only files committed
- [ ] Security review completed (no hardcoded secrets, no injection vulnerabilities)
- [ ] Error handling is adequate
- [ ] Code follows CLAUDE.md conventions

### Output
**1. Write `artifacts/auth-review/features.json`** — final feature status with `"reviewed": true` field added

**2. Write `artifacts/auth-review/review.md`** with these sections:
- **Feature Completeness**: For each feature in features.json, state: implemented/missing/stubbed and tested/untested
- **Test Suite Output**: Full pytest output from your test run
- **Issues Found**: Problems discovered, each with severity (CRITICAL / MAJOR / MINOR)
- **Fixes Applied**: Changes you made during review
- **Final Verdict**: APPROVE (ready to merge), or BLOCK (with specific reasons)


## Quality Requirements
- Write tests for any new functionality
- Do not break existing tests
- Follow the project's coding standards (see below)
- Implement all components fully — do not leave stub files

## Project Standards
# Project Standards & Conventions

## Tech Stack
- **Language**: Python 3.10+
- **Framework**: FastAPI (async web framework)
- **Database**: SQLAlchemy with SQLite/PostgreSQL (to be determined during implementation)
- **Authentication**: JWT (JSON Web Tokens)
- **Key Libraries**:
  - `fastapi`: Web framework
  - `sqlalchemy`: ORM
  - `pydantic`: Data validation
  - `python-jose`: JWT implementation
  - `passlib`: Password hashing
  - `pytest`: Testing framework
  - `pytest-asyncio`: Async test support
  - `pydentic-settings`: Configuration management
  - `structlog` or `python-logging`: Structured logging
  - `tenacity`: Circuit breaker/retry patterns

## Project Structure
```
auth-agent-1/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py                 # FastAPI application entry point
â”‚   â”œâ”€â”€ config.py               # Configuration settings
â”‚   â”œâ”€â”€ dependencies.py         # Dependency injection
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ user.py            # SQLAlchemy User model
â”‚   â”‚   â””â”€â”€ schemas.py         # Pydantic schemas for API
â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ auth.py            # Login/registration endpoints
â”‚   â”‚   â””â”€â”€ health.py          # Health check endpoint
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ auth_service.py    # Authentication business logic
â”‚   â”‚   â””â”€â”€ user_service.py    # User management
â”‚   â”œâ”€â”€ middleware/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ logging.py         # Request/response logging
â”‚   â”‚   â””â”€â”€ exception.py       # Global exception handler
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ jwt.py             # JWT utilities
â”‚   â”‚   â”œâ”€â”€ password.py        # Password hashing/verification
â”‚   â”‚   â”œâ”€â”€ circuit_breaker.py # Circuit breaker implementation
â”‚   â”‚   â””â”€â”€ logger.py          # Centralized logging setup
â”‚   â””â”€â”€ database.py            # Database connection management
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ conftest.py            # Pytest fixtures
â”‚   â”œâ”€â”€ unit/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ test_auth_service.py
â”‚   â”‚   â””â”€â”€ test_user_service.py
â”‚   â”œâ”€â”€ integration/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ test_auth_routes.py
â”‚   â”‚   â””â”€â”€ test_user_routes.py
â”‚   â””â”€â”€ fixtures/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â””â”€â”€ database.py
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ .env.example
â”œâ”€â”€ pytest.ini
â”œâ”€â”€ CLAUDE.md
â””â”€â”€ artifacts/
    â””â”€â”€ auth-analysis/
        â””â”€â”€ analysis.md
```

## Coding Conventions

### Python Style
- Follow PEP 8 conventions
- Use type hints for all function parameters and returns
- Use `snake_case` for variables, functions, and modules
- Use `PascalCase` for classes
- Imports: stdlib â†’ third-party â†’ local (one blank line between sections)
- Line length: 100 characters (for readability)

### FastAPI Patterns
- Use dependency injection via `Depends()` for authentication, logging, DB session
- Use path parameters for resource IDs, query parameters for filtering
- Return Pydantic models for all endpoints
- Use HTTP status codes appropriately (200, 201, 400, 401, 403, 404, 500)
- Include proper error responses with detail messages

### Database Patterns
- Use SQLAlchemy declarative base for models
- Use Pydantic schemas separate from ORM models
- Always use async context managers for DB sessions
- Implement repository pattern for data access

### Testing Patterns
- Pytest with pytest-asyncio for async support
- Use fixtures for common setup (DB, auth tokens, users)
- Separate unit tests from integration tests
- Use mocking for external dependencies
- Aim for 80%+ code coverage

### Logging Patterns
- Use structured logging (JSON format)
- Log levels: DEBUG, INFO, WARNING, ERROR, CRITICAL
- Include request ID in all log entries for traceability
- Log sensitive data redacted (never log passwords, tokens)

## Commands

### Development
```bash
# Install dependencies
pip install -r requirements.txt

# Run development server
uvicorn app.main:app --reload

# Run tests
pytest

# Run tests with coverage
pytest --cov=app tests/

# Run specific test file
pytest tests/unit/test_auth_service.py -v

# Lint code
flake8 app/ tests/

# Format code
black app/ tests/

# Type checking
mypy app/
```

### Database
```bash
# Create database schema
alembic upgrade head

# Generate migration
alembic revision --autogenerate -m "Description"
```

## Key Patterns

### Authentication Flow
- User registration: Create user, hash password, store in DB
- Login: Validate credentials, generate JWT token, return to client
- Protected routes: Validate JWT, extract user info from token, inject into route
- Token refresh: Implement refresh token mechanism for long-lived sessions

### Error Handling
- Custom exception hierarchy: `BaseException` â†’ `AuthException`, `ValidationException`, etc.
- Global exception handler middleware that catches all exceptions
- Return consistent error response format: `{"detail": "error message", "error_code": "CODE"}`

### Circuit Breaker
- Implement for external service calls (if applicable)
- States: Closed (normal), Open (fail fast), Half-Open (testing recovery)
- Track failures by service/endpoint
- Use exponential backoff for retries

### Dependency Injection
- `get_db()`: Provide DB session to routes
- `get_current_user()`: Validate JWT and return current user
- `get_logger()`: Provide configured logger to routes

## Configuration
- Use environment variables via `.env` file and `pydantic-settings`
- Separate configs: development, testing, production
- Never commit `.env` files with secrets
- Use `.env.example` template showing required variables

## Security Considerations
- Always hash passwords (bcrypt via passlib)
- Use HTTPS in production (enforced via settings)
- CORS configuration to restrict origin
- Implement rate limiting on auth endpoints
- JWT expiration: short-lived access tokens (15-30 min), long-lived refresh tokens (7 days)
- Add request ID middleware for audit trails
- Implement proper exception handling to avoid information disclosure

