' PlantUML Diagrams for Auth Service Test1
' Sequence Diagrams and Flow Diagrams

' ============================================================================
' SEQUENCE DIAGRAM 1: User Registration Flow
' ============================================================================
@startuml registration_flow
title User Registration Flow

actor Client
participant "FastAPI\nApplication" as API
participant "Register\nRoute" as Route
participant "Auth\nService" as AuthService
participant "User\nService" as UserService
participant "Password\nUtils" as PasswordUtils
participant "Database" as DB
participant "Logger" as Logger

Client -> API: POST /auth/register\n{username, email, password}
activate API
API -> Logger: Log incoming request with RequestID
activate Logger
Logger --> API:
deactivate Logger

API -> Route: validate input (Pydantic)
activate Route
Route -> AuthService: register_user(username, email, password)
activate AuthService

AuthService -> Logger: info("Starting registration")
activate Logger
Logger --> AuthService:
deactivate Logger

AuthService -> UserService: get_user_by_email(email)
activate UserService
UserService -> DB: query email
activate DB
DB --> UserService: user or None
deactivate DB
UserService --> AuthService: user_exists
deactivate UserService

alt User Already Exists
    AuthService -> AuthService: raise UserAlreadyExistsException
    AuthService -> Route: exception
end

AuthService -> UserService: get_user_by_username(username)
activate UserService
UserService -> DB: query username
activate DB
DB --> UserService: user or None
deactivate DB
UserService --> AuthService: user_exists
deactivate UserService

alt Username Already Exists
    AuthService -> AuthService: raise UserAlreadyExistsException
    AuthService -> Route: exception
end

AuthService -> PasswordUtils: hash_password(plain_password)
activate PasswordUtils
PasswordUtils --> AuthService: bcrypt_hash
deactivate PasswordUtils

AuthService -> UserService: create_user(username, email, hashed_password)
activate UserService
UserService -> DB: INSERT user
activate DB
DB --> UserService: user (with id)
deactivate DB
UserService --> AuthService: created_user
deactivate UserService

AuthService -> Logger: info("User created", extra={username, email})
activate Logger
Logger --> AuthService:
deactivate Logger

AuthService -> Route: user_data
deactivate AuthService

Route -> Route: Generate tokens (JWT)
Route -> Client: 201 Created\n{user, access_token, refresh_token}
deactivate Route

Client -> Logger: Log response
activate Logger
Logger --> API:
deactivate Logger

deactivate API
@enduml

' ============================================================================
' SEQUENCE DIAGRAM 2: User Login Flow
' ============================================================================
@startuml login_flow
title User Login Flow

actor Client
participant "FastAPI\nApplication" as API
participant "Login\nRoute" as Route
participant "Auth\nService" as AuthService
participant "User\nService" as UserService
participant "Password\nUtils" as PasswordUtils
participant "JWT\nUtils" as JWTUtils
participant "Database" as DB
participant "Logger" as Logger

Client -> API: POST /auth/login\n{email_or_username, password}
activate API
API -> Logger: Log incoming request (sanitized)
activate Logger
Logger --> API:
deactivate Logger

API -> Route: validate input
activate Route
Route -> AuthService: login(email_or_username, password)
activate AuthService

AuthService -> Logger: info("Login attempt")
activate Logger
Logger --> AuthService:
deactivate Logger

alt Email Provided
    AuthService -> UserService: get_user_by_email(email)
else Username Provided
    AuthService -> UserService: get_user_by_username(username)
end

activate UserService
UserService -> DB: query user
activate DB
DB --> UserService: user or None
deactivate DB
UserService --> AuthService: user
deactivate UserService

alt User Not Found
    AuthService -> AuthService: raise InvalidCredentialsException
    AuthService -> Route: exception
end

AuthService -> PasswordUtils: verify_password(password, hashed_password)
activate PasswordUtils
PasswordUtils --> AuthService: is_valid (boolean)
deactivate PasswordUtils

alt Password Invalid
    AuthService -> Logger: warning("Failed login attempt")
    activate Logger
    Logger --> AuthService:
    deactivate Logger
    AuthService -> AuthService: raise InvalidCredentialsException
    AuthService -> Route: exception
end

AuthService -> JWTUtils: create_access_token(user_id)
activate JWTUtils
JWTUtils --> AuthService: access_token_jwt
deactivate JWTUtils

AuthService -> JWTUtils: create_refresh_token(user_id)
activate JWTUtils
JWTUtils --> AuthService: refresh_token_jwt
deactivate JWTUtils

AuthService -> UserService: update_last_login(user_id)
activate UserService
UserService -> DB: UPDATE user.last_login = NOW()
activate DB
DB --> UserService: updated_user
deactivate DB
UserService --> AuthService:
deactivate UserService

AuthService -> Logger: info("User logged in", extra={user_id, username})
activate Logger
Logger --> AuthService:
deactivate Logger

AuthService --> Route: {tokens, user_data}
deactivate AuthService

Route -> Client: 200 OK\n{access_token, refresh_token, user}
deactivate Route

deactivate API
@enduml

' ============================================================================
' SEQUENCE DIAGRAM 3: Protected Route Access
' ============================================================================
@startuml protected_route_flow
title Protected Route Access with JWT Validation

actor Client
participant "FastAPI\nApplication" as API
participant "Protected\nRoute" as Route
participant "Dependencies" as Deps
participant "JWT\nUtils" as JWTUtils
participant "User\nService" as UserService
participant "Database" as DB
participant "Logger" as Logger
participant "Exception\nHandler" as ExceptionHandler

Client -> API: GET /protected-endpoint\nHeader: Authorization: Bearer <token>
activate API
API -> Logger: Log incoming request
activate Logger
Logger --> API:
deactivate Logger

API -> Route:
activate Route
Route -> Deps: get_current_user(token)
activate Deps

Deps -> Logger: debug("Validating token")
activate Logger
Logger --> Deps:
deactivate Logger

Deps -> Deps: Extract token from header
Deps -> JWTUtils: verify_token(token)
activate JWTUtils
JWTUtils --> Deps: decoded_payload or raise exception
deactivate JWTUtils

alt Invalid Token Signature
    Deps -> ExceptionHandler: handle TokenInvalidException
    activate ExceptionHandler
    ExceptionHandler -> Client: 401 Unauthorized\n{detail, error_code}
    deactivate ExceptionHandler
    deactivate Route
    deactivate API
end

alt Token Expired
    Deps -> ExceptionHandler: handle TokenExpiredException
    activate ExceptionHandler
    ExceptionHandler -> Client: 401 Unauthorized\n{detail, error_code}
    deactivate ExceptionHandler
    deactivate Route
    deactivate API
end

Deps -> Deps: Extract user_id from token
Deps -> UserService: get_user_by_id(user_id)
activate UserService
UserService -> DB: SELECT * FROM users WHERE id = ?
activate DB
DB --> UserService: user or None
deactivate DB
UserService --> Deps: user
deactivate UserService

alt User Not Found
    Deps -> ExceptionHandler: handle UserNotFound
    activate ExceptionHandler
    ExceptionHandler -> Client: 404 Not Found
    deactivate ExceptionHandler
    deactivate Route
    deactivate API
end

alt User Not Active
    Deps -> Logger: warning("Accessing inactive user")
    activate Logger
    Logger --> Deps:
    deactivate Logger
    Deps -> ExceptionHandler: handle InactiveUser
    activate ExceptionHandler
    ExceptionHandler -> Client: 403 Forbidden
    deactivate ExceptionHandler
    deactivate Route
    deactivate API
end

Deps -> Logger: debug("User authenticated", extra={user_id})
activate Logger
Logger --> Deps:
deactivate Logger

Deps --> Route: user_object
deactivate Deps

Route -> Route: Execute route handler with user context
Route -> Logger: Log response
activate Logger
Logger --> Route:
deactivate Logger

Route -> Client: 200 OK\n{protected_data}
deactivate Route

deactivate API
@enduml

' ============================================================================
' SEQUENCE DIAGRAM 4: Token Refresh Flow
' ============================================================================
@startuml token_refresh_flow
title Token Refresh Flow

actor Client
participant "FastAPI\nApplication" as API
participant "Refresh\nRoute" as Route
participant "Auth\nService" as AuthService
participant "JWT\nUtils" as JWTUtils
participant "User\nService" as UserService
participant "Database" as DB
participant "Logger" as Logger

Client -> API: POST /auth/refresh\n{refresh_token}
activate API
API -> Logger: Log incoming request
activate Logger
Logger --> API:
deactivate Logger

API -> Route: validate input
activate Route
Route -> AuthService: refresh_access_token(refresh_token)
activate AuthService

AuthService -> Logger: debug("Refreshing token")
activate Logger
Logger --> AuthService:
deactivate Logger

AuthService -> JWTUtils: verify_token(refresh_token)
activate JWTUtils
JWTUtils --> AuthService: decoded_payload or raise exception
deactivate JWTUtils

alt Token Invalid or Expired
    AuthService -> Logger: warning("Invalid refresh token")
    activate Logger
    Logger --> AuthService:
    deactivate Logger
    AuthService -> Route: raise TokenExpiredException
    Route -> Client: 401 Unauthorized
    deactivate Route
    deactivate API
end

AuthService -> Deps: Extract user_id from token
AuthService -> UserService: get_user_by_id(user_id)
activate UserService
UserService -> DB: SELECT * FROM users WHERE id = ?
activate DB
DB --> UserService: user
deactivate DB
UserService --> AuthService: user
deactivate UserService

AuthService -> JWTUtils: create_access_token(user_id)
activate JWTUtils
JWTUtils --> AuthService: new_access_token
deactivate JWTUtils

AuthService -> JWTUtils: create_refresh_token(user_id)
activate JWTUtils
JWTUtils --> AuthService: new_refresh_token
deactivate JWTUtils

AuthService -> Logger: info("Token refreshed", extra={user_id})
activate Logger
Logger --> AuthService:
deactivate Logger

AuthService --> Route: {new_access_token, new_refresh_token, user}
deactivate AuthService

Route -> Client: 200 OK\n{access_token, refresh_token, user}
deactivate Route

deactivate API
@enduml

' ============================================================================
' ACTIVITY DIAGRAM: Exception Handling Flow
' ============================================================================
@startuml exception_handling
title Exception Handling Flow - Global Exception Handler

start
: Route or Service Layer;
if (Exception Raised?) then (yes)
    : Capture Exception;
    if (AuthException) then (yes)
        : Set Status Code = 401;
        : error_code = "AUTH_ERROR";
    elseif (ValidationException) then (yes)
        : Set Status Code = 400;
        : error_code = "VALIDATION_ERROR";
    elseif (UserAlreadyExistsException) then (yes)
        : Set Status Code = 409;
        : error_code = "USER_EXISTS";
    elseif (InvalidCredentialsException) then (yes)
        : Set Status Code = 401;
        : error_code = "INVALID_CREDENTIALS";
    elseif (TokenExpiredException) then (yes)
        : Set Status Code = 401;
        : error_code = "TOKEN_EXPIRED";
    else (any other)
        : Set Status Code = 500;
        : error_code = "INTERNAL_ERROR";
    endif
    : Log Exception with RequestID;
    : Format Response:
    {
        "detail": "error message",
        "error_code": "CODE",
        "request_id": "UUID"
    };
    : Return Response;
else (no)
    : Continue Normal Flow;
endif
stop
@enduml

' ============================================================================
' STATE DIAGRAM: Circuit Breaker States
' ============================================================================
@startuml circuit_breaker_states
title Circuit Breaker State Machine

[*] --> CLOSED: Initialization

CLOSED --> CLOSED: Request succeeds\n(reset failure count)
CLOSED --> OPEN: Failure count >= THRESHOLD\n(default: 5)

OPEN --> OPEN: Request rejected\n(CircuitBreakerOpenException)
OPEN --> HALF_OPEN: TIMEOUT expires\n(default: 60 seconds)

HALF_OPEN --> CLOSED: Request succeeds\n(service recovered)
HALF_OPEN --> OPEN: Request fails\n(restart timeout)

note right of CLOSED
    Normal operation
    All requests pass through
    Failures tracked
end note

note right of OPEN
    Fail fast mode
    Immediate rejection
    Circuit rests for TIMEOUT
end note

note right of HALF_OPEN
    Recovery testing
    Limited requests allowed
    Test if service healthy
end note
@enduml

' ============================================================================
' DEPLOYMENT DIAGRAM: Component Interactions
' ============================================================================
@startuml component_diagram
title System Components and Interactions

package "Client Layer" {
    component "Web Browser" as Browser
    component "Mobile App" as Mobile
    component "External API" as External
}

package "FastAPI Application" {
    component "Router\n/auth/register\n/auth/login\n/auth/refresh\n/health" as Router

    component "Middleware" {
        component "RequestID\nGenerator" as ReqID
        component "Logging\nMiddleware" as LogMW
        component "Exception\nHandler" as ExceptionMW
    }

    component "Routes" {
        component "Auth Routes" as AuthRoutes
        component "Health Routes" as HealthRoutes
    }

    component "Services" {
        component "Auth Service" as AuthSvc
        component "User Service" as UserSvc
    }

    component "Dependencies" {
        component "get_current_user" as CurrentUser
        component "get_db_session" as DBSession
    }

    component "Utilities" {
        component "JWT Utils" as JWT
        component "Password Utils" as Password
        component "Logger" as LogUtil
        component "Circuit Breaker" as CB
        component "Exceptions" as Exc
    }
}

package "Data Layer" {
    component "SQLAlchemy\nORM" as SQLAlchemy
    component "SQLite/\nPostgreSQL" as Database
}

Browser --> Router: HTTPS
Mobile --> Router: HTTPS
External --> Router: HTTPS

Router --> ReqID: attach RequestID
ReqID --> LogMW: log request
LogMW --> ExceptionMW: pass through
ExceptionMW --> AuthRoutes: route request
ExceptionMW --> HealthRoutes: route request

AuthRoutes --> AuthSvc: call service
AuthRoutes --> CurrentUser: inject user
HealthRoutes --> HealthRoutes: simple response

AuthSvc --> UserSvc: manage users
UserSvc --> DBSession: get session
DBSession --> SQLAlchemy: ORM queries

AuthSvc --> JWT: create/verify tokens
AuthSvc --> Password: hash/verify
AuthSvc --> LogUtil: structured logging
AuthSvc --> Exc: custom exceptions

SQLAlchemy --> Database: SQL queries
@enduml

' ============================================================================
' SEQUENCE DIAGRAM: Middleware Processing Order
' ============================================================================
@startuml middleware_order
title Middleware Processing Order and Exception Handling

participant "Client" as Client
participant "RequestID\nMiddleware" as ReqID
participant "Logging\nMiddleware" as Log
participant "CORS\nMiddleware" as CORS
participant "RateLimit\nMiddleware" as RateLimit
participant "Route\nHandler" as Route
participant "Exception\nHandler\nMiddleware" as ExHandler

Client -> ReqID: HTTP Request
activate ReqID
ReqID -> ReqID: Generate UUID request_id
ReqID -> Log: Call next middleware
deactivate ReqID
activate Log

Log -> Log: Log request (sanitized)
Log -> CORS: Call next middleware
deactivate Log
activate CORS

CORS -> CORS: Check CORS headers
CORS -> RateLimit: Call next middleware
deactivate CORS
activate RateLimit

RateLimit -> RateLimit: Check rate limit
alt Rate Limit Exceeded
    RateLimit -> Client: 429 Too Many Requests
else
    RateLimit -> Route: Call route handler
    deactivate RateLimit
    activate Route

    Route -> Route: Execute endpoint logic

    alt Exception Raised
        Route -> ExHandler: Exception caught
        deactivate Route
        activate ExHandler
        ExHandler -> ExHandler: Format error response
        ExHandler -> Client: Error Response\n(with RequestID)
        deactivate ExHandler
    else
        Route -> Log: Response ready
        deactivate Route
        activate Log
        Log -> Log: Log response
        Log -> Client: HTTP Response\n(with RequestID header)
        deactivate Log
    end
end
@enduml
