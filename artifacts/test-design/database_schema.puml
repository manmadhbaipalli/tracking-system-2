@startuml database_schema

!define PK #ffaaaa
!define FK #aaaaff
!define REQUIRED #ffff99
!define OPTIONAL #ffffff

title Database Schema - Authentication Service

entity "users" as users {
    *id: INTEGER [PK]
    --
    *username: VARCHAR(50) [UNIQUE, REQUIRED]
    *email: VARCHAR(100) [UNIQUE, REQUIRED]
    *hashed_password: VARCHAR(255) [REQUIRED]
    *is_active: BOOLEAN [DEFAULT TRUE]
    created_at: TIMESTAMP [AUTO]
    updated_at: TIMESTAMP [AUTO]
    last_login: TIMESTAMP [OPTIONAL]
}

note right of users
  Primary Table for User Management

  Constraints:
  - username: UNIQUE, NOT NULL
  - email: UNIQUE, NOT NULL
  - hashed_password: NOT NULL, >255 chars (bcrypt)
  - is_active: NOT NULL, DEFAULT TRUE

  Indexes:
  - PRIMARY KEY (id)
  - UNIQUE INDEX (username)
  - UNIQUE INDEX (email)

  Fields:
  - id: Auto-increment primary key
  - username: Unique identifier for login
  - email: Unique email address
  - hashed_password: Bcrypt hash (never stored plain)
  - is_active: Soft delete / account status
  - created_at: Account creation timestamp
  - updated_at: Last modification timestamp
  - last_login: Track user activity (optional)
end note

@enduml

---

@startuml user_lifecycle

title User Lifecycle & State Transitions

[*] --> Registration

Registration --> Registered: POST /register\n{email, username, password}
note on link
  Password hashed with bcrypt
  is_active = TRUE
  created_at = NOW
end note

Registered --> Active: ready for login

Active --> Login: POST /login\n{credentials}
note on link
  Generates JWT tokens
  (access: 30 min, refresh: 7 days)
end note

Active --> Inactive: is_active = FALSE\n(admin or user action)

Inactive --> Login: Cannot login
Login --> Unauthorized: is_active = FALSE

Authorized: Login successful
Authorized --> TokenRefresh: access_token expires

TokenRefresh --> PostRefresh: POST /refresh\n{refresh_token}
note on link
  Valid refresh token
  New access_token generated
  refresh_token unchanged
end note

PostRefresh --> Active: New tokens returned

TokenRefresh --> Expired: refresh_token expired
Expired --> Unauthorized: Must login again

@enduml

---

@startuml migrations

title Database Initialization & Schema Management

start
:Application Startup;

:Check database exists;

if (Database\nfragment exists?) then (no)
  :Create database;
else (yes)
endif

:SQLAlchemy SessionMaker\nConfiguration;

:Create async engine;
note right
  Database URL from config:
  - Development: SQLite (:memory:)
  - Production: PostgreSQL
end note

:Call init_db();

:Begin transaction;

:Check users table exists;

if (Exists?) then (yes)
  :Skip creation;
else (no)
  :CREATE TABLE users;
  note right
    Columns:
    - id (PRIMARY KEY)
    - username (UNIQUE)
    - email (UNIQUE)
    - hashed_password
    - is_active
    - created_at
    - updated_at
    - last_login
  end note
endif

:Create indexes;
note right
  - idx_users_username
  - idx_users_email
end note

:Commit transaction;

:Database ready for queries;

stop

@enduml

---

@startuml data_flow

title Data Flow: Registration to Login

start
:User submits registration;
:POST /auth/register;
note right
  Body:
  {
    "email": "user@example.com",
    "username": "johndoe",
    "password": "mysecure123"
  }
end note

:FastAPI validates with Pydantic;

if (Valid?) then (no)
  :400 Bad Request;
  stop
else (yes)
endif

:AuthService.register_user();

:Check email not in DB;
:Check username not in DB;

:hash_password(password);
note right
  Bcrypt with salt
  Result: hashed_password
  Original password discarded
end note

:UserService.create_user();

:INSERT INTO users;
note right
  username: "johndoe"
  email: "user@example.com"
  hashed_password: "$2b$12$..."
  is_active: TRUE
  created_at: NOW
  updated_at: NOW
end note

:Retrieve user (get id);

:create_access_token(user_id);
note right
  Payload:
  {
    "sub": "1",
    "exp": NOW + 30min,
    "type": "access"
  }
  Signed with JWT_SECRET_KEY
end note

:create_refresh_token(user_id);
note right
  Payload:
  {
    "sub": "1",
    "exp": NOW + 7days,
    "type": "refresh"
  }
  Signed with JWT_SECRET_KEY
end note

:Return TokenResponse;
note right
  {
    "access_token": "eyJ...",
    "refresh_token": "eyJ...",
    "token_type": "bearer",
    "user": {
      "id": 1,
      "username": "johndoe",
      "email": "user@example.com",
      "is_active": true,
      "created_at": "..."
    }
  }
end note

:201 Created;

==Later: User Logs In==

:User submits login;
:POST /auth/login;
note right
  Body:
  {
    "email": "user@example.com",
    "password": "mysecure123"
  }
  OR
  {
    "username": "johndoe",
    "password": "mysecure123"
  }
end note

:AuthService.login();

:Query user by email or username;

:SELECT from users WHERE email=...;

:Verify password;
note right
  verify_password(
    "mysecure123",
    "$2b$12$..."
  )
  bcrypt constant-time comparison
end note

if (Match?) then (no)
  :401 Unauthorized;
  stop
else (yes)
endif

if (is_active?) then (no)
  :401 Unauthorized;
  stop
else (yes)
endif

:Generate new tokens;

:Return TokenResponse;
:200 OK;

stop

@enduml
