You are an autonomous coding agent. Your job is to complete the task below.

## Task: test-analysis
**[ANALYSIS] test**

**Pipeline:** `test` | **Phase:** `analysis`

## Description
1. Analyze the below requirement
	1. Create fastapi application with login, registration endpoints
	2. centralized logging system
	3. centralized exception handling
	4. implement circuit breaker
	5. swagger for all endpoints
2. Design the application
	1. Sequence Diagrams and flow diagrams in platuml
	2. design and create the db schema/tables
3. code implementation with proper testcases
4. execute testcases
5. review and optimize if any issues.

## Phase: analysis
Explore the codebase and analyze requirements. Identify affected files, dependencies, and risks. Write findings to artifacts/{task_id}/analysis.md.

## File Constraints
You may ONLY modify these files (other files are locked by other agents working in parallel):
  (no file restrictions — you may modify any file)

If you need to create new files, place them under the directories implied by the locked file paths.
Do NOT modify files outside your assigned scope — doing so will cause merge conflicts.

## Phase Role: Analysis
You are the **analysis agent**. Your job is to deeply explore the codebase and understand what needs to be built.

### What to do
1. Read the project structure — understand the tech stack, frameworks, and key modules
2. Identify all files, functions, and modules affected by this task
3. Map dependencies and potential ripple effects
4. Assess risks and edge cases
5. Note any existing tests that cover the affected areas
6. Determine the project's coding conventions, test runner, and build commands

### Output

**1. Write `CLAUDE.md` in the project root** with these sections:
- **Tech Stack**: Language, framework, database, key libraries
- **Project Structure**: Directory layout and what each directory contains
- **Coding Conventions**: Naming style, import ordering, formatting rules observed in existing code
- **Commands**: How to run tests (`pytest`, `npm test`, etc.), build, lint, and start the app
- **Key Patterns**: Any patterns used in existing code (e.g., repository pattern, dependency injection)

This file will be read by ALL subsequent agents as their coding standards reference.

**2. Write `artifacts/test-analysis/analysis.md`** with these sections:
- **Overview**: What the codebase does, tech stack, relevant entry points
- **Affected Areas**: Files and modules that need changes, with line references
- **Dependencies**: What depends on the affected code
- **Risks & Edge Cases**: What could go wrong, backward compatibility concerns
- **Recommendations**: Suggested approach for the implementation phase


## Quality Requirements
- Write tests for any new functionality
- Do not break existing tests
- Follow the project's coding standards (see below)
- Keep changes minimal and focused on the task

## Project Standards
# Auth Service Project Standards

## Tech Stack

- **Language**: Python 3.11+
- **Framework**: FastAPI (modern async web framework)
- **Database**: PostgreSQL (relational database for user data)
- **ORM**: SQLAlchemy (database abstraction layer)
- **Testing**: pytest (test framework with fixtures)
- **Package Manager**: pip / poetry
- **Async Support**: asyncio, httpx (for async HTTP calls)
- **Security**: PyJWT (JWT tokens), passlib + bcrypt (password hashing), python-multipart (form data)
- **API Documentation**: Swagger/OpenAPI (built into FastAPI)
- **Logging**: Python logging module (standard library)
- **Validation**: Pydantic (data validation and serialization)
- **Environment Configuration**: python-dotenv (environment variables)

## Project Structure

The project will follow this structure:

```
auth-service-agent-1/
â”œâ”€â”€ CLAUDE.md                          # This file - project standards
â”œâ”€â”€ README.md                          # Project documentation
â”œâ”€â”€ requirements.txt                   # Python dependencies
â”œâ”€â”€ .env.example                       # Example environment variables
â”œâ”€â”€ .gitignore                         # Git ignore rules
â”œâ”€â”€ app/                               # Main application package
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py                        # FastAPI app initialization
â”‚   â”œâ”€â”€ config.py                      # Configuration and settings
â”‚   â”œâ”€â”€ models/                        # SQLAlchemy ORM models
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ user.py                    # User model
â”‚   â”œâ”€â”€ schemas/                       # Pydantic schemas for request/response
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ user.py                    # User schemas (LoginRequest, RegisterRequest, etc.)
â”‚   â”œâ”€â”€ database/                      # Database setup and session management
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ connection.py              # Database connection and session factory
â”‚   â”œâ”€â”€ handlers/                      # Exception and error handlers
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ exceptions.py              # Custom exceptions and handlers
â”‚   â”œâ”€â”€ services/                      # Business logic layer
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ auth_service.py            # Authentication logic
â”‚   â”‚   â””â”€â”€ circuit_breaker.py         # Circuit breaker pattern
â”‚   â”œâ”€â”€ routers/                       # API route handlers
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ auth.py                    # /login, /register endpoints
â”‚   â”œâ”€â”€ middleware/                    # Custom middleware
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ logging.py                 # Logging middleware
â”‚   â””â”€â”€ utils/                         # Utility functions
â”‚       â”œâ”€â”€ __init__.py
â”‚       â””â”€â”€ security.py                # JWT, password hashing utilities
â”œâ”€â”€ migrations/                        # Alembic database migrations
â”‚   â”œâ”€â”€ versions/
â”‚   â”œâ”€â”€ env.py
â”‚   â”œâ”€â”€ script.py.mako
â”‚   â””â”€â”€ alembic.ini
â”œâ”€â”€ tests/                             # Test suite
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ conftest.py                    # Pytest fixtures and configuration
â”‚   â”œâ”€â”€ test_auth.py                   # Auth endpoint tests
â”‚   â”œâ”€â”€ test_models.py                 # Model tests
â”‚   â”œâ”€â”€ test_services.py               # Service layer tests
â”‚   â””â”€â”€ test_circuit_breaker.py        # Circuit breaker tests
â”œâ”€â”€ artifacts/                         # Analysis and design documents
â”‚   â””â”€â”€ auth-service-analysis/
â”‚       â”œâ”€â”€ analysis.md                # Detailed analysis document
â”‚       â”œâ”€â”€ database-schema.sql        # SQL schema
â”‚       â””â”€â”€ diagrams/                  # PlantUML diagrams
â”‚           â”œâ”€â”€ sequence-diagram.puml
â”‚           â””â”€â”€ flow-diagram.puml
â”œâ”€â”€ docker/                            # Docker configuration (optional)
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â””â”€â”€ docker-compose.yml
â””â”€â”€ scripts/                           # Utility scripts
    â””â”€â”€ setup_db.py                    # Database initialization script
```

## Coding Conventions

### Python Style
- **PEP 8 Compliance**: Follow PEP 8 with line length of 100 characters
- **Formatting**: Use Black for code formatting
- **Linting**: Use Flake8 or Ruff for linting
- **Type Hints**: Always use type hints for function signatures and class variables
- **Imports**: Organize imports in three groups: stdlib, third-party, local (sorted alphabetically within groups)
  ```python
  # stdlib
  import os
  from typing import Optional

  # third-party
  from fastapi import FastAPI, HTTPException
  from sqlalchemy import Column, String

  # local
  from app.config import settings
  from app.models.user import User
  ```

### Naming Conventions
- **Classes**: PascalCase (e.g., `UserService`, `AuthException`)
- **Functions/Methods**: snake_case (e.g., `validate_password`, `create_user`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `MAX_LOGIN_ATTEMPTS`, `TOKEN_EXPIRY`)
- **Private Methods**: Leading underscore (e.g., `_hash_password`)
- **Database Tables**: snake_case (e.g., `users`, `refresh_tokens`)

### Code Organization
- **One responsibility per class/module**: Follow Single Responsibility Principle
- **Async functions**: Use `async def` for I/O operations, prefix async context managers with `async with`
- **Exception handling**: Catch specific exceptions, not `Exception`
- **Logging**: Use module-level logger: `logger = logging.getLogger(__name__)`
- **Docstrings**: Use Google-style docstrings for public functions/classes:
  ```python
  def authenticate_user(username: str, password: str) -> Optional[User]:
      """Authenticate a user by username and password.

      Args:
          username: The user's username.
          password: The user's plaintext password.

      Returns:
          The authenticated User object or None if authentication fails.

      Raises:
          AuthenticationError: If authentication fails.
      """
  ```

### FastAPI Patterns
- **Dependency Injection**: Use FastAPI's `Depends()` for injecting dependencies
- **Request/Response Models**: Define Pydantic models for all endpoints
- **Status Codes**: Use appropriate HTTP status codes (200, 201, 400, 401, 403, 404, 500)
- **Error Responses**: Use `HTTPException` with consistent error format:
  ```python
  from fastapi import HTTPException
  raise HTTPException(status_code=401, detail="Invalid credentials")
  ```

### Database Patterns
- **SQLAlchemy Models**: Define ORM models in `models/` directory
- **Session Management**: Use context managers for database sessions
- **Migrations**: Use Alembic for schema migrations
- **Transactions**: Wrap operations in database transactions

### Testing Patterns
- **Test Organization**: Group tests by module (test_auth.py, test_services.py)
- **Fixtures**: Use pytest fixtures in `conftest.py` for setup/teardown
- **Mocking**: Use `unittest.mock` or `pytest-mock` for external dependencies
- **Test Names**: Use descriptive names: `test_register_user_success`, `test_login_invalid_password`
- **Coverage**: Aim for >80% code coverage

## Commands

### Setup & Installation
```bash
# Create virtual environment
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate

# Install dependencies
pip install -r requirements.txt

# Setup database
python scripts/setup_db.py
```

### Running the Application
```bash
# Development server with auto-reload
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000

# Production server
uvicorn app.main:app --host 0.0.0.0 --port 8000
```

### Testing
```bash
# Run all tests
pytest

# Run with coverage
pytest --cov=app --cov-report=html

# Run specific test file
pytest tests/test_auth.py

# Run with verbose output
pytest -v

# Run tests matching pattern
pytest -k "test_login"
```

### Database
```bash
# Create migrations
alembic revision --autogenerate -m "Add users table"

# Apply migrations
alembic upgrade head

# Rollback migration
alembic downgrade -1
```

### Code Quality
```bash
# Format code
black app/ tests/

# Lint code
flake8 app/ tests/

# Type checking
mypy app/

# All checks together
black --check app/ tests/ && flake8 app/ tests/ && mypy app/
```

### API Documentation
- **Swagger UI**: http://localhost:8000/docs
- **ReDoc**: http://localhost:8000/redoc
- **OpenAPI Schema**: http://localhost:8000/openapi.json

## Key Patterns

### 1. Service Layer Pattern
Business logic is separated from route handlers into service classes:
```python
# In app/services/auth_service.py
class AuthService:
    async def register_user(self, username: str, email: str, password: str) -> User:
        # Implementation

    async def authenticate_user(self, username: str, password: str) -> User:
        # Implementation
```

### 2. Dependency Injection
FastAPI's dependency system is used for injecting services and database sessions:
```python
async def get_db() -> AsyncGenerator[AsyncSession, None]:
    async with async_session_maker() as session:
        yield session

# In route handler
@router.post("/login")
async def login(request: LoginRequest, db: AsyncSession = Depends(get_db)):
    service = AuthService(db)
    return await service.authenticate_user(...)
```

### 3. Circuit Breaker Pattern
For external service calls, implement circuit breaker to handle failures:
```python
class CircuitBreaker:
    async def call(self, func, *args, **kwargs):
        # Check state and call function with fallback
```

### 4. Custom Exception Handling
Centralized exception handlers for consistent error responses:
```python
@app.exception_handler(AuthenticationError)
async def auth_error_handler(request, exc):
    return JSONResponse(
        status_code=401,
        content={"detail": str(exc)}
    )
```

### 5. Structured Logging
All modules use structured logging with correlation IDs for tracing:
```python
import logging
logger = logging.getLogger(__name__)

logger.info("User registration", extra={"user_id": user.id, "request_id": request_id})
```

## Development Workflow

1. **Create a new branch** for features: `git checkout -b feature/feature-name`
2. **Write tests first** (TDD approach when possible)
3. **Implement feature** following coding conventions
4. **Run tests and linters** before committing
5. **Commit with clear messages**: `git commit -m "feat: add user registration endpoint"`
6. **Create pull request** for code review

## Environment Variables

Create a `.env` file based on `.env.example`:
```
# Database
DATABASE_URL=postgresql+asyncpg://user:password@localhost/auth_db

# JWT
SECRET_KEY=your-secret-key-here
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=30

# Logging
LOG_LEVEL=INFO
LOG_FORMAT=json

# Circuit Breaker
CIRCUIT_BREAKER_FAILURE_THRESHOLD=5
CIRCUIT_BREAKER_RECOVERY_TIMEOUT=60

# Security
MAX_LOGIN_ATTEMPTS=5
LOGIN_ATTEMPT_TIMEOUT=900
```

## Notes for Agents

- This is a greenfield FastAPI project for building an authentication service
- All new code should be async-first (using `async`/`await`)
- Use SQLAlchemy ORM with async support (`asyncpg` driver for PostgreSQL)
- Implement comprehensive tests for all business logic
- Use Pydantic for request/response validation
- Centralize all error handling and logging
- Document all endpoints with OpenAPI decorators for Swagger

