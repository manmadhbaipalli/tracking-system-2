@startuml auth-service-sequence-diagrams

title Auth Service - Sequence Diagrams

== User Registration Flow ==

participant Client as C
participant "FastAPI\nEndpoint" as API
participant "Auth\nService" as Service
participant "Validator" as Validator
participant "Database" as DB

C -> API: POST /api/v1/auth/register\n{username, email, password}

API -> Validator: Validate input\n(format, length, complexity)
Validator --> API: Valid ✓

API -> Service: register_user(username, email, password)

Service -> Validator: Validate password strength\n(uppercase, lowercase, digit, special)
Validator --> Service: Valid ✓

Service -> DB: Check email exists
DB --> Service: Not found ✓

Service -> Service: Hash password\nwith bcrypt (cost=12)

Service -> DB: INSERT user\n(username, email, password_hash)
DB --> Service: user_id, timestamp
Service --> API: User object

API -> API: Generate JWT token
API --> C: 201 Created\n{user_id, username, email,\ntoken, token_expiry}

== User Login Flow with Rate Limiting ==

participant Client as C2
participant "FastAPI\nEndpoint" as API2
participant "Auth\nService" as Service2
participant "Login Attempts\nTracker" as RateLimit
participant "Database" as DB2

C2 -> API2: POST /api/v1/auth/login\n{username, password}

API2 -> Service2: authenticate_user(username, password)

Service2 -> RateLimit: Check recent attempts\n(last 15 minutes)
RateLimit -> DB2: SELECT COUNT failed attempts\nWHERE username = ? AND\nattempt_at > now() - 15 min
DB2 --> RateLimit: count = 3
RateLimit --> Service2: Attempts: 3/5

alt Attempts >= 5
    Service2 -> DB2: UPDATE users\nSET is_locked=true, locked_until=now()+30min
    DB2 --> Service2: Account locked
    Service2 --> API2: AuthenticationError("Account locked")
    API2 --> C2: 403 Forbidden\n{detail: "Account locked"}
else Attempts < 5

    Service2 -> DB2: SELECT user\nWHERE username = ?

    alt User not found
        DB2 --> Service2: NULL
        Service2 -> RateLimit: Log failed attempt
        RateLimit -> DB2: INSERT login_attempt\n(username, success=false, reason='user_not_found')
        DB2 --> RateLimit: success
        Service2 --> API2: AuthenticationError("Invalid credentials")
        API2 --> C2: 401 Unauthorized
    else User found

        DB2 --> Service2: user object

        Service2 -> Service2: Compare password hash\nwith bcrypt.verify()

        alt Password matches
            Service2 -> DB2: UPDATE users\nSET last_login_at=now(),\nfailed_login_attempts=0
            DB2 --> Service2: success

            Service2 -> RateLimit: Log successful attempt
            RateLimit -> DB2: INSERT login_attempt\n(username, success=true)
            DB2 --> RateLimit: success

            Service2 -> Service2: Generate JWT token\n(sub=user_id, exp=now()+30min)
            Service2 --> API2: User object + token
            API2 --> C2: 200 OK\n{access_token, token_type,\nexpires_in, user{id, username, email}}

        else Password doesn't match

            Service2 -> DB2: UPDATE users\nSET failed_login_attempts=failed+1
            DB2 --> Service2: attempts = 4

            Service2 -> RateLimit: Log failed attempt
            RateLimit -> DB2: INSERT login_attempt\n(username, success=false, reason='wrong_password')
            DB2 --> RateLimit: success

            Service2 --> API2: AuthenticationError("Invalid credentials")
            API2 --> C2: 401 Unauthorized
        end
    end
end

== Error Handling Flow ==

participant Client as C3
participant "Route\nHandler" as Handler
participant "Service/\nValidator" as Logic
participant "Exception\nHandler" as ExceptionHandler
participant "Logger" as Logger

C3 -> Handler: API Request

Handler -> Logic: Process request

alt Validation Error
    Logic --> Handler: ValidationError("Email invalid")
    Handler -> ExceptionHandler: Exception caught
    ExceptionHandler -> Logger: Log error\n(request_id, timestamp, type, message)
    Logger --> ExceptionHandler: logged
    ExceptionHandler --> C3: 422 Unprocessable Entity\n{detail: "Email invalid",\nerror_code: "VALIDATION_001",\nrequest_id: "req-xxx-yyy",\ntimestamp: "2026-02-19T..."}

else Authentication Error
    Logic --> Handler: AuthenticationError("Invalid credentials")
    Handler -> ExceptionHandler: Exception caught
    ExceptionHandler -> Logger: Log error\n(request_id, username, timestamp, type)
    Logger --> ExceptionHandler: logged
    ExceptionHandler --> C3: 401 Unauthorized\n{detail: "Invalid credentials",\nerror_code: "AUTH_001",\nrequest_id: "req-xxx-yyy",\ntimestamp: "2026-02-19T..."}

else Duplicate User
    Logic --> Handler: UserAlreadyExistsError("Email taken")
    Handler -> ExceptionHandler: Exception caught
    ExceptionHandler -> Logger: Log error
    Logger --> ExceptionHandler: logged
    ExceptionHandler --> C3: 409 Conflict\n{detail: "Email already registered",\nerror_code: "USER_CONFLICT",\nrequest_id: "req-xxx-yyy",\ntimestamp: "2026-02-19T..."}

else Database Error
    Logic --> Handler: DatabaseError("Connection timeout")
    Handler -> ExceptionHandler: Exception caught
    ExceptionHandler -> Logger: Log error\n(with full stack trace)
    Logger --> ExceptionHandler: logged
    ExceptionHandler --> C3: 500 Internal Server Error\n{detail: "Service unavailable",\nerror_code: "DB_001",\nrequest_id: "req-xxx-yyy",\ntimestamp: "2026-02-19T..."}

else Unexpected Error
    Logic --> Handler: RuntimeError("...")
    Handler -> ExceptionHandler: Exception caught
    ExceptionHandler -> Logger: Log error\n(with full stack trace)
    Logger --> ExceptionHandler: logged
    ExceptionHandler --> C3: 500 Internal Server Error\n{detail: "Internal server error",\nerror_code: "INTERNAL_ERROR",\nrequest_id: "req-xxx-yyy",\ntimestamp: "2026-02-19T..."}
end

== Circuit Breaker Pattern (External Service Call) ==

participant Client as C4
participant "App\nService" as AppService
participant "Circuit\nBreaker" as CB
participant "External\nService" as ExtService

note over CB
  Circuit Breaker States:
  - CLOSED: Normal operation
  - OPEN: Failing, block requests
  - HALF_OPEN: Testing recovery
end note

== Scenario 1: Normal Operation (CLOSED) ==
C4 -> AppService: Request

AppService -> CB: call(func, *args)

CB -> CB: Check state = CLOSED
activate CB #lightgreen

CB -> ExtService: Forward request
ExtService --> CB: Success ✓

CB -> CB: Reset failure count = 0
CB --> AppService: Return result
AppService --> C4: Response

== Scenario 2: Service Failing (→ OPEN) ==
AppService -> CB: call(func, *args)

CB -> CB: Check state = CLOSED
activate CB #FFE4E1

CB -> ExtService: Forward request
ExtService --> CB: Timeout ✗

CB -> CB: failure_count += 1
CB -> CB: failure_count > threshold?

alt Yes - Open circuit
    CB -> CB: state = OPEN
    CB -> CB: recovery_timeout = now() + 60s
    CB --> AppService: CircuitBreakerOpenError()
    AppService --> C4: 503 Service Unavailable
else No
    CB --> AppService: Timeout error
    AppService --> C4: Error response
end

== Scenario 3: Recovery Attempt (HALF_OPEN) ==
AppService -> CB: call(func, *args)

note over CB
  Recovery timeout expired,
  testing if service recovered
end note

CB -> CB: Check state = HALF_OPEN
activate CB #FFFACD

CB -> ExtService: Test request
ExtService --> CB: Success ✓

CB -> CB: success_count += 1
alt success_count >= 2
    CB -> CB: state = CLOSED
    CB -> CB: Reset all counters
    CB --> AppService: Return result
    deactivate CB
else Keep trying
    CB --> AppService: Return result
end

@enduml
